// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: emails.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const countAllEmails = `-- name: CountAllEmails :one
SELECT COUNT(*) FROM emails
`

func (q *Queries) CountAllEmails(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAllEmails)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEmailsByMailbox = `-- name: CountEmailsByMailbox :one
SELECT COUNT(*) FROM emails WHERE mailbox_id = ?
`

func (q *Queries) CountEmailsByMailbox(ctx context.Context, mailboxID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEmailsByMailbox, mailboxID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchEmails = `-- name: CountSearchEmails :one
SELECT COUNT(*) FROM emails
WHERE mailbox_id = ?
AND (subject LIKE ? OR from_address LIKE ?)
`

type CountSearchEmailsParams struct {
	MailboxID   int64          `json:"mailbox_id"`
	Subject     sql.NullString `json:"subject"`
	FromAddress string         `json:"from_address"`
}

func (q *Queries) CountSearchEmails(ctx context.Context, arg CountSearchEmailsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSearchEmails, arg.MailboxID, arg.Subject, arg.FromAddress)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUnreadByMailbox = `-- name: CountUnreadByMailbox :one
SELECT COUNT(*) FROM emails WHERE mailbox_id = ? AND is_read = 0
`

func (q *Queries) CountUnreadByMailbox(ctx context.Context, mailboxID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUnreadByMailbox, mailboxID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEmail = `-- name: CreateEmail :one
INSERT INTO emails (
    mailbox_id, message_id, from_address, to_address, subject,
    date, headers, text_body, html_body, raw_size, is_read, received_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 0, CURRENT_TIMESTAMP)
RETURNING id, mailbox_id, message_id, from_address, to_address, subject, date, headers, text_body, html_body, raw_size, received_at, is_read
`

type CreateEmailParams struct {
	MailboxID   int64          `json:"mailbox_id"`
	MessageID   sql.NullString `json:"message_id"`
	FromAddress string         `json:"from_address"`
	ToAddress   string         `json:"to_address"`
	Subject     sql.NullString `json:"subject"`
	Date        sql.NullString `json:"date"`
	Headers     sql.NullString `json:"headers"`
	TextBody    sql.NullString `json:"text_body"`
	HtmlBody    sql.NullString `json:"html_body"`
	RawSize     int64          `json:"raw_size"`
}

func (q *Queries) CreateEmail(ctx context.Context, arg CreateEmailParams) (Email, error) {
	row := q.db.QueryRowContext(ctx, createEmail,
		arg.MailboxID,
		arg.MessageID,
		arg.FromAddress,
		arg.ToAddress,
		arg.Subject,
		arg.Date,
		arg.Headers,
		arg.TextBody,
		arg.HtmlBody,
		arg.RawSize,
	)
	var i Email
	err := row.Scan(
		&i.ID,
		&i.MailboxID,
		&i.MessageID,
		&i.FromAddress,
		&i.ToAddress,
		&i.Subject,
		&i.Date,
		&i.Headers,
		&i.TextBody,
		&i.HtmlBody,
		&i.RawSize,
		&i.ReceivedAt,
		&i.IsRead,
	)
	return i, err
}

const deleteEmail = `-- name: DeleteEmail :exec
DELETE FROM emails WHERE id = ?
`

func (q *Queries) DeleteEmail(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteEmail, id)
	return err
}

const deleteOldEmails = `-- name: DeleteOldEmails :exec
DELETE FROM emails WHERE received_at < ?
`

func (q *Queries) DeleteOldEmails(ctx context.Context, receivedAt time.Time) error {
	_, err := q.db.ExecContext(ctx, deleteOldEmails, receivedAt)
	return err
}

const deleteOldEmailsByMailbox = `-- name: DeleteOldEmailsByMailbox :exec
DELETE FROM emails WHERE mailbox_id = ? AND received_at < ?
`

type DeleteOldEmailsByMailboxParams struct {
	MailboxID  int64     `json:"mailbox_id"`
	ReceivedAt time.Time `json:"received_at"`
}

func (q *Queries) DeleteOldEmailsByMailbox(ctx context.Context, arg DeleteOldEmailsByMailboxParams) error {
	_, err := q.db.ExecContext(ctx, deleteOldEmailsByMailbox, arg.MailboxID, arg.ReceivedAt)
	return err
}

const getEmailByID = `-- name: GetEmailByID :one
SELECT id, mailbox_id, message_id, from_address, to_address, subject, date, headers, text_body, html_body, raw_size, received_at, is_read FROM emails WHERE id = ? LIMIT 1
`

func (q *Queries) GetEmailByID(ctx context.Context, id int64) (Email, error) {
	row := q.db.QueryRowContext(ctx, getEmailByID, id)
	var i Email
	err := row.Scan(
		&i.ID,
		&i.MailboxID,
		&i.MessageID,
		&i.FromAddress,
		&i.ToAddress,
		&i.Subject,
		&i.Date,
		&i.Headers,
		&i.TextBody,
		&i.HtmlBody,
		&i.RawSize,
		&i.ReceivedAt,
		&i.IsRead,
	)
	return i, err
}

const getMailboxStats = `-- name: GetMailboxStats :one
SELECT
    COUNT(*) as email_count,
    MAX(received_at) as last_email_at
FROM emails WHERE mailbox_id = ?
`

type GetMailboxStatsRow struct {
	EmailCount  int64       `json:"email_count"`
	LastEmailAt interface{} `json:"last_email_at"`
}

func (q *Queries) GetMailboxStats(ctx context.Context, mailboxID int64) (GetMailboxStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getMailboxStats, mailboxID)
	var i GetMailboxStatsRow
	err := row.Scan(&i.EmailCount, &i.LastEmailAt)
	return i, err
}

const listEmailsByMailbox = `-- name: ListEmailsByMailbox :many
SELECT id, mailbox_id, message_id, from_address, to_address, subject, date, headers, text_body, html_body, raw_size, received_at, is_read FROM emails
WHERE mailbox_id = ?
ORDER BY received_at DESC
LIMIT ? OFFSET ?
`

type ListEmailsByMailboxParams struct {
	MailboxID int64 `json:"mailbox_id"`
	Limit     int64 `json:"limit"`
	Offset    int64 `json:"offset"`
}

func (q *Queries) ListEmailsByMailbox(ctx context.Context, arg ListEmailsByMailboxParams) ([]Email, error) {
	rows, err := q.db.QueryContext(ctx, listEmailsByMailbox, arg.MailboxID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Email{}
	for rows.Next() {
		var i Email
		if err := rows.Scan(
			&i.ID,
			&i.MailboxID,
			&i.MessageID,
			&i.FromAddress,
			&i.ToAddress,
			&i.Subject,
			&i.Date,
			&i.Headers,
			&i.TextBody,
			&i.HtmlBody,
			&i.RawSize,
			&i.ReceivedAt,
			&i.IsRead,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markEmailAsRead = `-- name: MarkEmailAsRead :exec
UPDATE emails SET is_read = 1 WHERE id = ?
`

func (q *Queries) MarkEmailAsRead(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markEmailAsRead, id)
	return err
}

const markEmailAsUnread = `-- name: MarkEmailAsUnread :exec
UPDATE emails SET is_read = 0 WHERE id = ?
`

func (q *Queries) MarkEmailAsUnread(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markEmailAsUnread, id)
	return err
}

const searchEmails = `-- name: SearchEmails :many
SELECT id, mailbox_id, message_id, from_address, to_address, subject, date, headers, text_body, html_body, raw_size, received_at, is_read FROM emails
WHERE mailbox_id = ?
AND (subject LIKE ? OR from_address LIKE ?)
ORDER BY received_at DESC
LIMIT ? OFFSET ?
`

type SearchEmailsParams struct {
	MailboxID   int64          `json:"mailbox_id"`
	Subject     sql.NullString `json:"subject"`
	FromAddress string         `json:"from_address"`
	Limit       int64          `json:"limit"`
	Offset      int64          `json:"offset"`
}

func (q *Queries) SearchEmails(ctx context.Context, arg SearchEmailsParams) ([]Email, error) {
	rows, err := q.db.QueryContext(ctx, searchEmails,
		arg.MailboxID,
		arg.Subject,
		arg.FromAddress,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Email{}
	for rows.Next() {
		var i Email
		if err := rows.Scan(
			&i.ID,
			&i.MailboxID,
			&i.MessageID,
			&i.FromAddress,
			&i.ToAddress,
			&i.Subject,
			&i.Date,
			&i.Headers,
			&i.TextBody,
			&i.HtmlBody,
			&i.RawSize,
			&i.ReceivedAt,
			&i.IsRead,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
