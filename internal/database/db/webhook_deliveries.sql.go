// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: webhook_deliveries.sql

package db

import (
	"context"
	"database/sql"
)

const countDeliveriesByStatus = `-- name: CountDeliveriesByStatus :one
SELECT COUNT(*) FROM webhook_deliveries WHERE webhook_id = ? AND status = ?
`

type CountDeliveriesByStatusParams struct {
	WebhookID int64  `json:"webhook_id"`
	Status    string `json:"status"`
}

func (q *Queries) CountDeliveriesByStatus(ctx context.Context, arg CountDeliveriesByStatusParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDeliveriesByStatus, arg.WebhookID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDeliveriesByWebhook = `-- name: CountDeliveriesByWebhook :one
SELECT COUNT(*) FROM webhook_deliveries WHERE webhook_id = ?
`

func (q *Queries) CountDeliveriesByWebhook(ctx context.Context, webhookID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDeliveriesByWebhook, webhookID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDelivery = `-- name: CreateDelivery :one
INSERT INTO webhook_deliveries (
    webhook_id, email_id, attempt, status,
    request_body, created_at
)
VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
RETURNING id, webhook_id, email_id, attempt, status, status_code, request_body, response_body, error_message, duration_ms, created_at
`

type CreateDeliveryParams struct {
	WebhookID   int64          `json:"webhook_id"`
	EmailID     int64          `json:"email_id"`
	Attempt     int64          `json:"attempt"`
	Status      string         `json:"status"`
	RequestBody sql.NullString `json:"request_body"`
}

func (q *Queries) CreateDelivery(ctx context.Context, arg CreateDeliveryParams) (WebhookDelivery, error) {
	row := q.db.QueryRowContext(ctx, createDelivery,
		arg.WebhookID,
		arg.EmailID,
		arg.Attempt,
		arg.Status,
		arg.RequestBody,
	)
	var i WebhookDelivery
	err := row.Scan(
		&i.ID,
		&i.WebhookID,
		&i.EmailID,
		&i.Attempt,
		&i.Status,
		&i.StatusCode,
		&i.RequestBody,
		&i.ResponseBody,
		&i.ErrorMessage,
		&i.DurationMs,
		&i.CreatedAt,
	)
	return i, err
}

const getDeliveryByID = `-- name: GetDeliveryByID :one
SELECT id, webhook_id, email_id, attempt, status, status_code, request_body, response_body, error_message, duration_ms, created_at FROM webhook_deliveries WHERE id = ? LIMIT 1
`

func (q *Queries) GetDeliveryByID(ctx context.Context, id int64) (WebhookDelivery, error) {
	row := q.db.QueryRowContext(ctx, getDeliveryByID, id)
	var i WebhookDelivery
	err := row.Scan(
		&i.ID,
		&i.WebhookID,
		&i.EmailID,
		&i.Attempt,
		&i.Status,
		&i.StatusCode,
		&i.RequestBody,
		&i.ResponseBody,
		&i.ErrorMessage,
		&i.DurationMs,
		&i.CreatedAt,
	)
	return i, err
}

const getWebhookDeliveryStats = `-- name: GetWebhookDeliveryStats :one
SELECT
    COUNT(*) as total,
    SUM(CASE WHEN status = 'success' THEN 1 ELSE 0 END) as success_count,
    SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) as failed_count,
    SUM(CASE WHEN status = 'pending' OR status = 'retrying' THEN 1 ELSE 0 END) as pending_count
FROM webhook_deliveries WHERE webhook_id = ?
`

type GetWebhookDeliveryStatsRow struct {
	Total        int64           `json:"total"`
	SuccessCount sql.NullFloat64 `json:"success_count"`
	FailedCount  sql.NullFloat64 `json:"failed_count"`
	PendingCount sql.NullFloat64 `json:"pending_count"`
}

func (q *Queries) GetWebhookDeliveryStats(ctx context.Context, webhookID int64) (GetWebhookDeliveryStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getWebhookDeliveryStats, webhookID)
	var i GetWebhookDeliveryStatsRow
	err := row.Scan(
		&i.Total,
		&i.SuccessCount,
		&i.FailedCount,
		&i.PendingCount,
	)
	return i, err
}

const listDeliveriesByEmail = `-- name: ListDeliveriesByEmail :many
SELECT id, webhook_id, email_id, attempt, status, status_code, request_body, response_body, error_message, duration_ms, created_at FROM webhook_deliveries
WHERE email_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListDeliveriesByEmail(ctx context.Context, emailID int64) ([]WebhookDelivery, error) {
	rows, err := q.db.QueryContext(ctx, listDeliveriesByEmail, emailID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookDelivery{}
	for rows.Next() {
		var i WebhookDelivery
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.EmailID,
			&i.Attempt,
			&i.Status,
			&i.StatusCode,
			&i.RequestBody,
			&i.ResponseBody,
			&i.ErrorMessage,
			&i.DurationMs,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeliveriesByWebhook = `-- name: ListDeliveriesByWebhook :many
SELECT id, webhook_id, email_id, attempt, status, status_code, request_body, response_body, error_message, duration_ms, created_at FROM webhook_deliveries
WHERE webhook_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListDeliveriesByWebhookParams struct {
	WebhookID int64 `json:"webhook_id"`
	Limit     int64 `json:"limit"`
	Offset    int64 `json:"offset"`
}

func (q *Queries) ListDeliveriesByWebhook(ctx context.Context, arg ListDeliveriesByWebhookParams) ([]WebhookDelivery, error) {
	rows, err := q.db.QueryContext(ctx, listDeliveriesByWebhook, arg.WebhookID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookDelivery{}
	for rows.Next() {
		var i WebhookDelivery
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.EmailID,
			&i.Attempt,
			&i.Status,
			&i.StatusCode,
			&i.RequestBody,
			&i.ResponseBody,
			&i.ErrorMessage,
			&i.DurationMs,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingDeliveries = `-- name: ListPendingDeliveries :many
SELECT id, webhook_id, email_id, attempt, status, status_code, request_body, response_body, error_message, duration_ms, created_at FROM webhook_deliveries
WHERE status = 'pending' OR status = 'retrying'
ORDER BY created_at ASC
LIMIT ?
`

func (q *Queries) ListPendingDeliveries(ctx context.Context, limit int64) ([]WebhookDelivery, error) {
	rows, err := q.db.QueryContext(ctx, listPendingDeliveries, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookDelivery{}
	for rows.Next() {
		var i WebhookDelivery
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.EmailID,
			&i.Attempt,
			&i.Status,
			&i.StatusCode,
			&i.RequestBody,
			&i.ResponseBody,
			&i.ErrorMessage,
			&i.DurationMs,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDelivery = `-- name: UpdateDelivery :one
UPDATE webhook_deliveries
SET status = ?, status_code = ?, response_body = ?, error_message = ?, duration_ms = ?
WHERE id = ?
RETURNING id, webhook_id, email_id, attempt, status, status_code, request_body, response_body, error_message, duration_ms, created_at
`

type UpdateDeliveryParams struct {
	Status       string         `json:"status"`
	StatusCode   sql.NullInt64  `json:"status_code"`
	ResponseBody sql.NullString `json:"response_body"`
	ErrorMessage sql.NullString `json:"error_message"`
	DurationMs   sql.NullInt64  `json:"duration_ms"`
	ID           int64          `json:"id"`
}

func (q *Queries) UpdateDelivery(ctx context.Context, arg UpdateDeliveryParams) (WebhookDelivery, error) {
	row := q.db.QueryRowContext(ctx, updateDelivery,
		arg.Status,
		arg.StatusCode,
		arg.ResponseBody,
		arg.ErrorMessage,
		arg.DurationMs,
		arg.ID,
	)
	var i WebhookDelivery
	err := row.Scan(
		&i.ID,
		&i.WebhookID,
		&i.EmailID,
		&i.Attempt,
		&i.Status,
		&i.StatusCode,
		&i.RequestBody,
		&i.ResponseBody,
		&i.ErrorMessage,
		&i.DurationMs,
		&i.CreatedAt,
	)
	return i, err
}

const cancelRetryingByWebhook = `-- name: CancelRetryingByWebhook :exec
UPDATE webhook_deliveries
SET status = 'failed', error_message = 'Cancelled by user'
WHERE webhook_id = ? AND status = 'retrying'
`

func (q *Queries) CancelRetryingByWebhook(ctx context.Context, webhookID int64) error {
	_, err := q.db.ExecContext(ctx, cancelRetryingByWebhook, webhookID)
	return err
}

const deleteAllByWebhook = `-- name: DeleteAllByWebhook :exec
DELETE FROM webhook_deliveries WHERE webhook_id = ?
`

func (q *Queries) DeleteAllByWebhook(ctx context.Context, webhookID int64) error {
	_, err := q.db.ExecContext(ctx, deleteAllByWebhook, webhookID)
	return err
}
